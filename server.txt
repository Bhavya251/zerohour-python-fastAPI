from fastapi import FastAPI, APIRouter, WebSocket, WebSocketDisconnect, HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
from pathlib import Path
from pydantic import BaseModel, Field, EmailStr
from typing import List, Optional, Dict
import uuid
from datetime import datetime, timedelta
import json
import jwt
from passlib.context import CryptContext

ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# MongoDB connection
mongo_url = os.environ['MONGO_URL']
client = AsyncIOMotorClient(mongo_url)
db = client[os.environ['DB_NAME']]

# JWT and Password settings
SECRET_KEY = "your-secret-key-change-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Password encryption - using pbkdf2_sha256 instead of bcrypt to avoid byte length issues
pwd_context = CryptContext(schemes=["pbkdf2_sha256"], deprecated="auto")
security = HTTPBearer()


# WebSocket connection manager
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}

    async def connect(self, websocket: WebSocket, user_id: str):
        await websocket.accept()
        self.active_connections[user_id] = websocket

    def disconnect(self, user_id: str):
        if user_id in self.active_connections:
            del self.active_connections[user_id]

    async def send_personal_message(self, message: str, user_id: str):
        if user_id in self.active_connections:
            await self.active_connections[user_id].send_text(message)

    async def send_message_to_chat(self, message: dict, chat_id: str):
        # Find all users in this chat and send message
        chat = await db.chats.find_one({"chat_id": chat_id})
        if chat:
            for participant_id in chat.get("participants", []):
                if participant_id in self.active_connections:
                    await self.active_connections[participant_id].send_text(json.dumps(message))


manager = ConnectionManager()

# Create the main app
app = FastAPI(title="ZeroHour Chat API", version="1.0.0")
api_router = APIRouter(prefix="/api")


# Models
class User(BaseModel):
    user_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    first_name: str
    last_name: str
    mobile_no: str
    email: EmailStr
    username: str
    security_phrase: str
    created_at: datetime = Field(default_factory=datetime.now)
    is_online: bool = False


class UserRegister(BaseModel):
    first_name: str
    last_name: str
    mobile_no: str
    email: EmailStr
    username: str
    password: str
    security_phrase: str


class UserLogin(BaseModel):
    username: str
    password: str


class Chat(BaseModel):
    chat_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    participants: List[str]  # List of user_ids
    created_at: datetime = Field(default_factory=datetime.now)
    last_message: Optional[str] = None
    last_message_time: Optional[datetime] = None


class Message(BaseModel):
    message_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    chat_id: str
    sender_id: str
    content: str
    timestamp: datetime = Field(default_factory=datetime.now)
    message_type: str = "text"  # text, image, file


class Token(BaseModel):
    access_token: str
    token_type: str
    user_data: dict


# Utility functions
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password):
    return pwd_context.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now() + expires_delta
    else:
        expire = datetime.now() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")

    user = await db.users.find_one({"username": username})
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")
    return User(**user)


# Authentication endpoints
@api_router.post("/auth/register", response_model=Token)
async def register_user(user_data: UserRegister):
    # Check if username or email already exists
    existing_user = await db.users.find_one({
        "$or": [
            {"username": user_data.username},
            {"email": user_data.email}
        ]
    })

    if existing_user:
        raise HTTPException(status_code=400, detail="Username or email already registered")

    # Hash password
    hashed_password = get_password_hash(user_data.password)

    # Create user
    user_dict = user_data.model_dump()
    user_dict.pop("password")

    user = User(**user_dict)
    user_db_dict = user.model_dump()
    user_db_dict["password_hash"] = hashed_password

    await db.users.insert_one(user_db_dict)

    # Create access token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )

    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user_data": {
            "user_id": user.user_id,
            "username": user.username,
            "first_name": user.first_name,
            "last_name": user.last_name,
            "email": user.email
        }
    }


@api_router.post("/auth/login", response_model=Token)
async def login_user(user_credentials: UserLogin):
    user = await db.users.find_one({"username": user_credentials.username})

    if not user or not verify_password(user_credentials.password, user["password_hash"]):
        raise HTTPException(status_code=401, detail="Incorrect username or password")

    # Update online status
    await db.users.update_one(
        {"user_id": user["user_id"]},
        {"$set": {"is_online": True}}
    )

    # Create access token
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user["username"]}, expires_delta=access_token_expires
    )

    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user_data": {
            "user_id": user["user_id"],
            "username": user["username"],
            "first_name": user["first_name"],
            "last_name": user["last_name"],
            "email": user["email"]
        }
    }


@api_router.post("/auth/logout")
async def logout_user(current_user: User = Depends(get_current_user)):
    # Update online status
    await db.users.update_one(
        {"user_id": current_user.user_id},
        {"$set": {"is_online": False}}
    )
    return {"message": "Successfully logged out"}


# User endpoints
@api_router.get("/users/search")
async def search_users(query: str, current_user: User = Depends(get_current_user)):
    users = await db.users.find({
        "$and": [
            {"user_id": {"$ne": current_user.user_id}},
            {"$or": [
                {"username": {"$regex": query, "$options": "i"}},
                {"first_name": {"$regex": query, "$options": "i"}},
                {"last_name": {"$regex": query, "$options": "i"}}
            ]}
        ]
    }).to_list(20)

    return [
        {
            "user_id": user["user_id"],
            "username": user["username"],
            "first_name": user["first_name"],
            "last_name": user["last_name"],
            "is_online": user.get("is_online", False)
        } for user in users
    ]


# Chat endpoints
@api_router.post("/chats/create")
async def create_chat(other_user_id: str, current_user: User = Depends(get_current_user)):
    # Check if chat already exists between these users
    existing_chat = await db.chats.find_one({
        "participants": {"$all": [current_user.user_id, other_user_id]}
    })

    if existing_chat:
        return Chat(**existing_chat)

    # Create new chat
    chat = Chat(participants=[current_user.user_id, other_user_id])
    await db.chats.insert_one(chat.model_dump())
    return chat


@api_router.get("/chats", response_model=List[dict])
async def get_user_chats(current_user: User = Depends(get_current_user)):
    chats = await db.chats.find({
        "participants": current_user.user_id
    }).to_list(100)

    # Enhance chats with other participant info
    enhanced_chats = []
    for chat in chats:
        other_user_id = [p for p in chat["participants"] if p != current_user.user_id][0]
        other_user = await db.users.find_one({"user_id": other_user_id})

        enhanced_chat = {
            "chat_id": chat["chat_id"],
            "other_user": {
                "user_id": other_user["user_id"],
                "username": other_user["username"],
                "first_name": other_user["first_name"],
                "last_name": other_user["last_name"],
                "is_online": other_user.get("is_online", False)
            },
            "last_message": chat.get("last_message"),
            "last_message_time": chat.get("last_message_time"),
            "created_at": chat["created_at"]
        }
        enhanced_chats.append(enhanced_chat)

    # Sort by last message time
    enhanced_chats.sort(key=lambda x: x.get("last_message_time") or x["created_at"], reverse=True)
    return enhanced_chats


@api_router.get("/chats/{chat_id}/messages", response_model=List[dict])
async def get_chat_messages(chat_id: str, current_user: User = Depends(get_current_user)):
    # Verify user is participant in chat
    chat = await db.chats.find_one({"chat_id": chat_id})
    if not chat or current_user.user_id not in chat["participants"]:
        raise HTTPException(status_code=403, detail="Access denied")

    messages = await db.messages.find({"chat_id": chat_id}).sort("timestamp", 1).to_list(1000)

    # Enhance messages with sender info
    enhanced_messages = []
    for message in messages:
        sender = await db.users.find_one({"user_id": message["sender_id"]})
        enhanced_message = {
            "message_id": message["message_id"],
            "content": message["content"],
            "timestamp": message["timestamp"],
            "sender": {
                "user_id": sender["user_id"],
                "username": sender["username"],
                "first_name": sender["first_name"],
                "last_name": sender["last_name"]
            },
            "is_own_message": message["sender_id"] == current_user.user_id
        }
        enhanced_messages.append(enhanced_message)

    return enhanced_messages


# WebSocket endpoint
@app.websocket("/ws/{user_id}")
async def websocket_endpoint(websocket: WebSocket, user_id: str):
    await manager.connect(websocket, user_id)
    try:
        while True:
            data = await websocket.receive_text()
            message_data = json.loads(data)

            # Create message in database
            message = Message(
                chat_id=message_data["chat_id"],
                sender_id=user_id,
                content=message_data["content"]
            )

            await db.messages.insert_one(message.model_dump())

            # Update chat's last message
            await db.chats.update_one(
                {"chat_id": message_data["chat_id"]},
                {
                    "$set": {
                        "last_message": message_data["content"],
                        "last_message_time": message.timestamp
                    }
                }
            )

            # Get sender info
            sender = await db.users.find_one({"user_id": user_id})

            # Broadcast to chat participants
            broadcast_message = {
                "message_id": message.message_id,
                "chat_id": message.chat_id,
                "content": message.content,
                "timestamp": message.timestamp.isoformat(),
                "sender": {
                    "user_id": sender["user_id"],
                    "username": sender["username"],
                    "first_name": sender["first_name"],
                    "last_name": sender["last_name"]
                }
            }

            await manager.send_message_to_chat(broadcast_message, message.chat_id)

    except WebSocketDisconnect:
        manager.disconnect(user_id)
        # Update user offline status
        await db.users.update_one(
            {"user_id": user_id},
            {"$set": {"is_online": False}}
        )


# Health check
@api_router.get("/")
async def root():
    return {"message": "ZeroHour Chat API is running!"}


# Include the router in the main app
app.include_router(api_router)

app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()
